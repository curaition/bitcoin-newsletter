"""Newsletter task monitoring and health checks."""

import logging
from datetime import UTC, datetime, timedelta
from typing import Any, Optional

from crypto_newsletter.core.storage.repository import NewsletterRepository
from crypto_newsletter.shared.database.connection import get_db_session
from crypto_newsletter.shared.models import ArticleAnalysis, Newsletter
from sqlalchemy import and_, desc, func, select
from sqlalchemy.ext.asyncio import AsyncSession

logger = logging.getLogger(__name__)


class NewsletterTaskMonitor:
    """Monitor newsletter generation tasks and health."""

    def __init__(self, db_session: Optional[AsyncSession] = None):
        """Initialize newsletter task monitor."""
        self.db = db_session
        self._should_close_db = db_session is None

    async def __aenter__(self):
        """Async context manager entry."""
        if self.db is None:
            self.db = await get_db_session().__aenter__()
        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        """Async context manager exit."""
        if self._should_close_db and self.db:
            await self.db.close()

    async def get_newsletter_generation_status(self) -> dict[str, Any]:
        """
        Get comprehensive newsletter generation status.

        Returns:
            Dict with newsletter generation health and metrics
        """
        try:
            newsletter_repo = NewsletterRepository(self.db)

            # Get recent newsletter generation statistics
            now = datetime.now(UTC)
            past_7_days = now - timedelta(days=7)
            past_24_hours = now - timedelta(hours=24)

            # Get newsletters from past 7 days
            recent_newsletters = await newsletter_repo.get_newsletters_by_date_range(
                start_date=past_7_days.date(), end_date=now.date()
            )

            # Separate daily and weekly newsletters
            daily_newsletters = [
                n
                for n in recent_newsletters
                if n.generation_metadata
                and n.generation_metadata.get("newsletter_type") == "DAILY"
            ]

            weekly_newsletters = [
                n
                for n in recent_newsletters
                if n.generation_metadata
                and n.generation_metadata.get("newsletter_type") == "WEEKLY"
            ]

            # Calculate success rates and metrics
            daily_stats = await self._calculate_newsletter_stats(
                daily_newsletters, "DAILY"
            )
            weekly_stats = await self._calculate_newsletter_stats(
                weekly_newsletters, "WEEKLY"
            )

            # Check for recent generation failures
            recent_failures = await self._check_recent_failures(past_24_hours)

            # Check if daily newsletter should have been generated today
            today = now.date()
            daily_today = [n for n in daily_newsletters if n.generation_date == today]

            # Check if weekly newsletter should have been generated this week
            # (Monday is day 0 in Python's weekday())
            days_since_monday = now.weekday()
            this_monday = now.date() - timedelta(days=days_since_monday)
            weekly_this_week = [
                n for n in weekly_newsletters if n.generation_date >= this_monday
            ]

            # Determine overall newsletter health status
            status = "healthy"
            issues = []

            # Check daily newsletter generation
            if now.hour >= 7 and not daily_today:  # Should be generated by 7 AM UTC
                status = "warning"
                issues.append("Daily newsletter not generated today")

            # Check weekly newsletter generation (only on Monday after 9 AM UTC)
            if now.weekday() == 0 and now.hour >= 9 and not weekly_this_week:
                status = "warning"
                issues.append("Weekly newsletter not generated this week")

            # Check for recent failures
            if recent_failures["total_failures"] > 0:
                if recent_failures["total_failures"] >= 3:
                    status = "unhealthy"
                else:
                    status = "warning"
                issues.append(
                    f"{recent_failures['total_failures']} recent generation failures"
                )

            # Check success rates
            if daily_stats["success_rate"] < 0.8:  # Less than 80% success rate
                status = "warning"
                issues.append(
                    f"Daily newsletter success rate low: {daily_stats['success_rate']:.1%}"
                )

            return {
                "status": status,
                "timestamp": now.isoformat(),
                "issues": issues,
                "metrics": {
                    "daily_newsletters": daily_stats,
                    "weekly_newsletters": weekly_stats,
                    "recent_failures": recent_failures,
                    "generation_schedule": {
                        "daily_generated_today": len(daily_today) > 0,
                        "weekly_generated_this_week": len(weekly_this_week) > 0,
                        "next_daily_due": "06:00 UTC daily",
                        "next_weekly_due": "08:00 UTC Monday",
                    },
                },
            }

        except Exception as e:
            logger.error(f"Newsletter status check failed: {e}")
            return {
                "status": "unhealthy",
                "timestamp": datetime.now(UTC).isoformat(),
                "error": str(e),
                "issues": ["Newsletter monitoring system error"],
            }

    async def _calculate_newsletter_stats(
        self, newsletters: list[Newsletter], newsletter_type: str
    ) -> dict[str, Any]:
        """Calculate statistics for a list of newsletters."""
        if not newsletters:
            return {
                "total_count": 0,
                "success_count": 0,
                "success_rate": 0.0,
                "average_quality_score": 0.0,
                "average_generation_cost": 0.0,
                "average_processing_time": 0.0,
                "last_generated": None,
            }

        # Count successful generations (not failed or cancelled)
        successful = [n for n in newsletters if n.status not in ["FAILED", "CANCELLED"]]

        # Calculate averages
        quality_scores = [n.quality_score for n in successful if n.quality_score]
        avg_quality = (
            sum(quality_scores) / len(quality_scores) if quality_scores else 0.0
        )

        generation_costs = []
        processing_times = []

        for newsletter in successful:
            if newsletter.generation_metadata:
                cost = newsletter.generation_metadata.get("generation_cost", 0.0)
                if cost:
                    generation_costs.append(cost)

                proc_time = newsletter.generation_metadata.get(
                    "processing_time_seconds", 0.0
                )
                if proc_time:
                    processing_times.append(proc_time)

        avg_cost = (
            sum(generation_costs) / len(generation_costs) if generation_costs else 0.0
        )
        avg_time = (
            sum(processing_times) / len(processing_times) if processing_times else 0.0
        )

        # Get most recent newsletter
        sorted_newsletters = sorted(
            newsletters, key=lambda n: n.generation_date, reverse=True
        )
        last_generated = (
            sorted_newsletters[0].generation_date.isoformat()
            if sorted_newsletters
            else None
        )

        return {
            "total_count": len(newsletters),
            "success_count": len(successful),
            "success_rate": len(successful) / len(newsletters) if newsletters else 0.0,
            "average_quality_score": round(avg_quality, 2),
            "average_generation_cost": round(avg_cost, 4),
            "average_processing_time": round(avg_time, 2),
            "last_generated": last_generated,
        }

    async def _check_recent_failures(self, since_date: datetime) -> dict[str, Any]:
        """Check for recent newsletter generation failures."""
        try:
            # Query for failed newsletters since the given date
            query = (
                select(Newsletter)
                .where(
                    and_(
                        Newsletter.created_at >= since_date,
                        Newsletter.status == "FAILED",
                    )
                )
                .order_by(desc(Newsletter.created_at))
            )

            result = await self.db.execute(query)
            failed_newsletters = result.scalars().all()

            failure_details = []
            for newsletter in failed_newsletters:
                failure_info = {
                    "id": newsletter.id,
                    "newsletter_type": newsletter.generation_metadata.get(
                        "newsletter_type", "UNKNOWN"
                    )
                    if newsletter.generation_metadata
                    else "UNKNOWN",
                    "failed_at": newsletter.created_at.isoformat(),
                    "error": newsletter.generation_metadata.get(
                        "error", "Unknown error"
                    )
                    if newsletter.generation_metadata
                    else "Unknown error",
                }
                failure_details.append(failure_info)

            return {
                "total_failures": len(failed_newsletters),
                "failure_details": failure_details,
            }

        except Exception as e:
            logger.error(f"Failed to check recent failures: {e}")
            return {"total_failures": 0, "failure_details": [], "error": str(e)}

    async def get_newsletter_pipeline_health(self) -> dict[str, Any]:
        """
        Check health of newsletter generation pipeline dependencies.

        Returns:
            Dict with pipeline health status
        """
        try:
            # Check if we have sufficient analyzed articles for newsletter generation
            now = datetime.now(UTC)
            past_24_hours = now - timedelta(hours=24)

            # Count analyzed articles from past 24 hours
            query = select(func.count(ArticleAnalysis.id)).where(
                and_(
                    ArticleAnalysis.created_at >= past_24_hours,
                    ArticleAnalysis.validation_status == "COMPLETED",
                    ArticleAnalysis.signal_strength >= 0.5,
                )
            )

            result = await self.db.execute(query)
            analyzed_articles_count = result.scalar() or 0

            # Determine pipeline health
            status = "healthy"
            issues = []

            if analyzed_articles_count < 10:  # Minimum threshold for daily newsletter
                if analyzed_articles_count < 5:
                    status = "unhealthy"
                    issues.append(
                        f"Critically low analyzed articles: {analyzed_articles_count}"
                    )
                else:
                    status = "warning"
                    issues.append(
                        f"Low analyzed articles for newsletter: {analyzed_articles_count}"
                    )

            return {
                "status": status,
                "timestamp": now.isoformat(),
                "issues": issues,
                "metrics": {
                    "analyzed_articles_24h": analyzed_articles_count,
                    "minimum_required": 10,
                    "pipeline_ready": analyzed_articles_count >= 10,
                },
            }

        except Exception as e:
            logger.error(f"Newsletter pipeline health check failed: {e}")
            return {
                "status": "unhealthy",
                "timestamp": datetime.now(UTC).isoformat(),
                "error": str(e),
                "issues": ["Newsletter pipeline monitoring error"],
            }


async def get_newsletter_health_status() -> dict[str, Any]:
    """
    Get comprehensive newsletter system health status.

    Returns:
        Dict with complete newsletter health information
    """
    async with NewsletterTaskMonitor() as monitor:
        generation_status = await monitor.get_newsletter_generation_status()
        pipeline_status = await monitor.get_newsletter_pipeline_health()

        # Determine overall status
        overall_status = "healthy"
        if (
            generation_status["status"] == "unhealthy"
            or pipeline_status["status"] == "unhealthy"
        ):
            overall_status = "unhealthy"
        elif (
            generation_status["status"] == "warning"
            or pipeline_status["status"] == "warning"
        ):
            overall_status = "warning"

        return {
            "overall_status": overall_status,
            "timestamp": datetime.now(UTC).isoformat(),
            "checks": {
                "newsletter_generation": generation_status,
                "newsletter_pipeline": pipeline_status,
            },
        }
